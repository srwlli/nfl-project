# Team Season Stats Table - Raw Data Source Mapping

> **Purpose**: Maps each database field to its raw data source
> **Date Generated**: October 22, 2025
> **Data Source**: Database (games table) - NOT ESPN API
> **CodeRef**: `transformToTeamSeasonStats` at standings-scraper.js:202

---

## Executive Summary

This document shows **exactly** where each field in the `team_season_stats` table comes from. Unlike other tables, team_season_stats is **calculated entirely from the database**, not from ESPN API.

**Calculation Process**: Lines 34-224 of standings-scraper.js
**Primary Data Source**: `games` table (status='final')
**Secondary Data Source**: `teams` table (for division/conference)
**Automation**: Daily at 7:00 AM ET via scheduler

---

## Data Source: Database Games Table

### Query Used

```javascript
const { data: games } = await supabase
  .from('games')
  .select('*')
  .eq('season', 2025)
  .eq('status', 'final')
```

**Why Database Instead of ESPN**:
- More reliable than ESPN API
- Ensures data consistency
- No rate limits
- Already have complete game data
- Avoids ESPN API discrepancies

---

## Field-by-Field Mapping (11 Fields)

### 1. team_season_stat_id
- **Database Column**: `team_season_stat_id`
- **Data Type**: SERIAL (auto-increment)
- **Raw Source**: Generated by database
- **API Path**: N/A
- **Transformation**: None
- **Example Raw**: N/A
- **Example Stored**: `123`
- **Notes**: Primary key, auto-increments

---

### 2. team_id
- **Database Column**: `team_id`
- **Data Type**: VARCHAR(10)
- **Raw Source**: Teams table
- **API Path**: `teams.team_id`
- **Transformation**: Direct copy
- **Example Raw**: `"KC"`
- **Example Stored**: `"KC"`
- **Script**: standings-scraper.js lines 56-80
- **Notes**: Foreign key to teams table

**Code**:
```javascript
const { data: teams } = await supabase
  .from('teams')
  .select('team_id, division, conference')

teams.forEach(team => {
  teamRecords.set(team.team_id, {
    team_id: team.team_id,
    // ...
  })
})
```

---

### 3. season
- **Database Column**: `season`
- **Data Type**: INTEGER
- **Raw Source**: Function parameter / constant
- **API Path**: N/A
- **Transformation**: Direct value
- **Example Raw**: `2025`
- **Example Stored**: `2025`
- **Script**: standings-scraper.js line 211
- **Notes**: Foreign key to seasons table

**Code**:
```javascript
return {
  season: season,  // Passed as function parameter
  // ...
}
```

---

### 4. games_played
- **Database Column**: `games_played`
- **Data Type**: INTEGER
- **Raw Source**: COUNTED from games table
- **API Path**: N/A (calculated)
- **Transformation**: Count games where team participated
- **Example Raw**: 17 games found
- **Example Stored**: `17`
- **Script**: standings-scraper.js lines 92-94
- **Notes**: Incremented for each completed game

**Code**:
```javascript
games.forEach(game => {
  const homeTeam = teamRecords.get(game.home_team_id)
  const awayTeam = teamRecords.get(game.away_team_id)

  homeTeam.games_played++  // Count for home team
  awayTeam.games_played++  // Count for away team
})
```

**Calculation**:
```
games_played = COUNT(*) FROM games
  WHERE (home_team_id = team_id OR away_team_id = team_id)
    AND season = 2025
    AND status = 'final'
```

---

### 5. wins
- **Database Column**: `wins`
- **Data Type**: INTEGER
- **Raw Source**: CALCULATED from games table
- **API Path**: N/A (calculated)
- **Transformation**: Count wins from game scores
- **Example Raw**: 12 games won
- **Example Stored**: `12`
- **Script**: standings-scraper.js lines 102-108
- **Notes**: Compares home_score vs away_score

**Code**:
```javascript
const homeScore = game.home_score || 0
const awayScore = game.away_score || 0

if (homeScore > awayScore) {
  homeTeam.wins++  // Home team won
  awayTeam.losses++
} else if (awayScore > homeScore) {
  awayTeam.wins++  // Away team won
  homeTeam.losses++
} else {
  homeTeam.ties++
  awayTeam.ties++
}
```

**Calculation Logic**:
```
For each game:
  If home_team_id = team_id AND home_score > away_score: wins++
  If away_team_id = team_id AND away_score > home_score: wins++
```

---

### 6. losses
- **Database Column**: `losses`
- **Data Type**: INTEGER
- **Raw Source**: CALCULATED from games table
- **API Path**: N/A (calculated)
- **Transformation**: Count losses from game scores
- **Example Raw**: 5 games lost
- **Example Stored**: `5`
- **Script**: standings-scraper.js lines 102-108
- **Notes**: Same logic as wins, opposite result

**Calculation Logic**:
```
For each game:
  If home_team_id = team_id AND home_score < away_score: losses++
  If away_team_id = team_id AND away_score < home_score: losses++
```

---

### 7. ties
- **Database Column**: `ties`
- **Data Type**: INTEGER
- **Raw Source**: CALCULATED from games table
- **API Path**: N/A (calculated)
- **Transformation**: Count ties from game scores
- **Example Raw**: 0 games tied
- **Example Stored**: `0`
- **Script**: standings-scraper.js lines 109-112
- **Notes**: home_score == away_score

**Calculation Logic**:
```
For each game:
  If home_score == away_score: ties++ (for both teams)
```

---

### 8. win_percentage
- **Database Column**: `win_percentage`
- **Data Type**: DECIMAL(5,4)
- **Raw Source**: CALCULATED from wins/losses/ties
- **API Path**: N/A (calculated)
- **Transformation**: (wins + ties × 0.5) / games_played
- **Example Raw**: 12 wins, 5 losses, 0 ties, 17 games
- **Example Stored**: `0.7059`
- **Script**: standings-scraper.js lines 205-216
- **Notes**: Ties count as 0.5 wins (NFL rule)

**Code**:
```javascript
const winPct = team.games_played > 0
  ? (team.wins + team.ties * 0.5) / team.games_played
  : 0

return {
  win_percentage: parseFloat(winPct.toFixed(4))
}
```

**Formula**:
```
win_percentage = (wins + (ties × 0.5)) / games_played

Examples:
  12 wins, 5 losses, 0 ties, 17 games → (12 + 0) / 17 = 0.7059
  10 wins, 5 losses, 2 ties, 17 games → (10 + 1) / 17 = 0.6471
```

---

### 9. points_for
- **Database Column**: `points_for`
- **Data Type**: INTEGER
- **Raw Source**: SUMMED from games table
- **API Path**: N/A (summed)
- **Transformation**: Sum of team's scores across all games
- **Example Raw**: Sum of all home_score + away_score
- **Example Stored**: `425`
- **Script**: standings-scraper.js lines 96-100
- **Notes**: Offensive performance metric

**Code**:
```javascript
homeTeam.points_for += homeScore  // Add home team's score
homeTeam.points_against += awayScore

awayTeam.points_for += awayScore  // Add away team's score
awayTeam.points_against += homeScore
```

**Calculation**:
```
points_for = SUM(
  CASE
    WHEN home_team_id = team_id THEN home_score
    WHEN away_team_id = team_id THEN away_score
  END
)
```

---

### 10. points_against
- **Database Column**: `points_against`
- **Data Type**: INTEGER
- **Raw Source**: SUMMED from games table
- **API Path**: N/A (summed)
- **Transformation**: Sum of opponent scores
- **Example Raw**: Sum of opponent scores
- **Example Stored**: `312`
- **Script**: standings-scraper.js lines 96-100
- **Notes**: Defensive performance metric

**Calculation**:
```
points_against = SUM(
  CASE
    WHEN home_team_id = team_id THEN away_score
    WHEN away_team_id = team_id THEN home_score
  END
)
```

---

### 11. point_differential
- **Database Column**: `point_differential`
- **Data Type**: INTEGER
- **Raw Source**: CALCULATED from points_for - points_against
- **API Path**: N/A (calculated)
- **Transformation**: Subtraction
- **Example Raw**: 425 - 312
- **Example Stored**: `113`
- **Script**: standings-scraper.js line 219
- **Notes**: Used as tiebreaker in rankings

**Code**:
```javascript
return {
  point_differential: team.points_for - team.points_against
}
```

**Formula**:
```
point_differential = points_for - points_against

Examples:
  425 points for, 312 against → +113
  280 points for, 350 against → -70
```

---

### 12. division_rank
- **Database Column**: `division_rank`
- **Data Type**: INTEGER
- **Raw Source**: CALCULATED from standings
- **API Path**: N/A (calculated)
- **Transformation**: Sort by win%, then point_differential
- **Example Raw**: 1st in AFC West
- **Example Stored**: `1`
- **Script**: standings-scraper.js lines 121-155
- **Notes**: Range 1-4 (4 teams per division)

**Code**:
```javascript
// Group teams by division
const divisionKey = `${team.conference}-${team.division}`

// Sort by win percentage, then point differential
teams.sort((a, b) => {
  const aWinPct = a.games_played > 0 ? (a.wins + a.ties * 0.5) / a.games_played : 0
  const bWinPct = b.games_played > 0 ? (b.wins + b.ties * 0.5) / b.games_played : 0

  if (aWinPct !== bWinPct) return bWinPct - aWinPct

  // Tiebreaker: point differential
  const aDiff = a.points_for - a.points_against
  const bDiff = b.points_for - b.points_against
  return bDiff - aDiff
})

// Assign ranks
teams.forEach((team, index) => {
  team.division_rank = index + 1
})
```

**Ranking Logic**:
1. Sort by win_percentage (descending)
2. Tiebreaker: point_differential (descending)
3. Assign rank 1-4

**Limitations**: Does NOT use head-to-head record, division record, or other official NFL tiebreakers.

---

### 13. conference_rank
- **Database Column**: `conference_rank`
- **Data Type**: INTEGER
- **Raw Source**: CALCULATED from standings
- **API Path**: N/A (calculated)
- **Transformation**: Sort by win%, then point_differential
- **Example Raw**: 3rd in AFC
- **Example Stored**: `3`
- **Script**: standings-scraper.js lines 157-197
- **Notes**: Range 1-16 (16 teams per conference)

**Code**:
```javascript
// Group by conference (AFC or NFC)
const conferences = {
  'AFC': [],
  'NFC': []
}

// Sort by win percentage, then point differential
teams.sort((a, b) => {
  const aWinPct = a.games_played > 0 ? (a.wins + a.ties * 0.5) / a.games_played : 0
  const bWinPct = b.games_played > 0 ? (b.wins + b.ties * 0.5) / b.games_played : 0

  if (aWinPct !== bWinPct) return bWinPct - aWinPct

  // Tiebreaker: point differential
  const aDiff = a.points_for - a.points_against
  const bDiff = b.points_for - b.points_against
  return bDiff - aDiff
})

// Assign ranks
teams.forEach((team, index) => {
  team.conference_rank = index + 1
})
```

**Ranking Logic**:
1. Sort by win_percentage (descending)
2. Tiebreaker: point_differential (descending)
3. Assign rank 1-16

**Limitations**: Does NOT use strength of victory, strength of schedule, or other official NFL tiebreakers.

---

### 14-16. Metadata (created_at, updated_at, deleted_at)
- **Database Columns**: `created_at`, `updated_at`, `deleted_at`
- **Data Type**: TIMESTAMP
- **Raw Source**: Database triggers
- **API Path**: N/A
- **Transformation**: None
- **Example Raw**: N/A
- **Example Stored**: `"2025-10-20T16:30:00Z"`
- **Notes**: Managed by database automatically

---

## Complete Data Flow Example

### Step 1: Fetch Games from Database

```javascript
const { data: games } = await supabase
  .from('games')
  .select('*')
  .eq('season', 2025)
  .eq('status', 'final')

// Example: 106 completed games
```

### Step 2: Initialize Team Records

```javascript
const { data: teams } = await supabase
  .from('teams')
  .select('team_id, division, conference')

// Create record for each team
teams.forEach(team => {
  teamRecords.set(team.team_id, {
    team_id: team.team_id,
    division: team.division,
    conference: team.conference,
    wins: 0,
    losses: 0,
    ties: 0,
    points_for: 0,
    points_against: 0,
    games_played: 0
  })
})
```

### Step 3: Process Each Game

```javascript
games.forEach(game => {
  const homeTeam = teamRecords.get(game.home_team_id)  // e.g., "KC"
  const awayTeam = teamRecords.get(game.away_team_id)  // e.g., "DEN"

  const homeScore = game.home_score  // e.g., 28
  const awayScore = game.away_score  // e.g., 21

  // Increment games played
  homeTeam.games_played++  // KC: 1 game
  awayTeam.games_played++  // DEN: 1 game

  // Update points
  homeTeam.points_for += homeScore        // KC: +28
  homeTeam.points_against += awayScore    // KC: +21
  awayTeam.points_for += awayScore        // DEN: +21
  awayTeam.points_against += homeScore    // DEN: +28

  // Determine winner
  if (homeScore > awayScore) {
    homeTeam.wins++   // KC: 1 win
    awayTeam.losses++ // DEN: 1 loss
  }
})
```

**After all 106 games processed**:
```javascript
{
  team_id: "KC",
  division: "West",
  conference: "AFC",
  wins: 12,
  losses: 5,
  ties: 0,
  points_for: 425,
  points_against: 312,
  games_played: 17
}
```

### Step 4: Calculate Win Percentage

```javascript
const winPct = (12 + 0 * 0.5) / 17 = 0.7059
```

### Step 5: Calculate Rankings

**Division Ranking**:
```javascript
// AFC West teams
[
  { team_id: "KC", win_pct: 0.7059, point_diff: +113 },
  { team_id: "LAC", win_pct: 0.6471, point_diff: +45 },
  { team_id: "DEN", win_pct: 0.5294, point_diff: -12 },
  { team_id: "LV", win_pct: 0.3529, point_diff: -87 }
]

// Assign ranks
KC: division_rank = 1
LAC: division_rank = 2
DEN: division_rank = 3
LV: division_rank = 4
```

**Conference Ranking**:
```javascript
// All 16 AFC teams sorted
KC: conference_rank = 3  // (e.g., Buffalo #1, Baltimore #2, KC #3)
```

### Step 6: Transform to Schema

```javascript
{
  team_id: "KC",
  season: 2025,
  games_played: 17,
  wins: 12,
  losses: 5,
  ties: 0,
  win_percentage: 0.7059,
  points_for: 425,
  points_against: 312,
  point_differential: 113,
  division_rank: 1,
  conference_rank: 3
}
```

### Step 7: Upsert to Database

```javascript
const result = await upsertBatch('team_season_stats', teamSeasonStats, ['team_id', 'season'])
// Updates existing or inserts new
```

---

## Data Extraction Workflow

### Trigger

**Scheduler** (daily at 7:00 AM ET):
```javascript
// From scheduler.js
cron.schedule('0 7 * * *', async () => {
  await runScript('scrapers/standings-scraper.js')
})
```

### Manual Execution

```bash
npm run scrape:standings
```

### Process

1. Fetch all completed games from database
2. Initialize records for all 32 teams
3. Process each game to calculate wins/losses/points
4. Calculate division rankings (sort + assign 1-4)
5. Calculate conference rankings (sort + assign 1-16)
6. Transform to team_season_stats schema
7. Upsert to database (update or insert)

---

## Common Data Issues

### Issue 1: Rankings Don't Match NFL Official Standings

**Symptom**: conference_rank differs from NFL.com

**Cause**: We only use win_percentage and point_differential as tiebreakers.

**Missing Tiebreakers**:
- Head-to-head record
- Division record
- Conference record
- Common games record
- Strength of victory
- Strength of schedule

**Solution**: Treat as approximation, not official standings.

### Issue 2: Stats Update Daily, Not Real-Time

**Symptom**: Stats lag behind completed games until next day

**Cause**: Scheduler runs at 7:00 AM ET

**Solution**: Run manually after games complete:
```bash
npm run scrape:standings
```

### Issue 3: Games Must Be status='final'

**Symptom**: Stats don't include games still in progress

**Cause**: Query filters `WHERE status = 'final'`

**Solution**: Expected behavior - only count completed games.

---

## Why Database Instead of ESPN API?

### Advantages

1. **Reliability**: Own database is source of truth
2. **Consistency**: All data comes from same source
3. **No Rate Limits**: Unlimited queries
4. **Accuracy**: We control game data quality
5. **Flexibility**: Can add custom tiebreakers later

### Disadvantages

1. **Manual Calculation**: Must implement ranking logic ourselves
2. **Tiebreaker Limitations**: Don't have head-to-head, division record, etc.
3. **Dependency**: Requires games table to be populated first

---

## Version History

| Version | Date | Changes |
|---------|------|---------|
| 1.0 | 2025-10-01 | Initial standings-scraper created |
| 1.1 | 2025-10-18 | Enhanced with division/conference rankings |
| 1.2 | 2025-10-22 | Documentation created with calculation details |

---

## References

- **Scraper**: `scripts/scrapers/standings-scraper.js` (lines 34-224)
- **CodeRef Location**: `transformToTeamSeasonStats:202`
- **Data Source**: Database `games` table (NOT ESPN API)
- **Migration**: `supabase/migrations/20250101000007_create_team_stats_tables.sql` (lines 8-29)

---

**Last Updated**: October 22, 2025
**Data Source**: Database (games table) for accuracy
**Total Fields**: 11 (+ 3 metadata)
**Automation**: ✅ Daily at 7:00 AM ET via scheduler
**CodeRef Validation**: ✅ All fields calculated and match schema perfectly
